# 项目介绍文档

## 选择的赛题

proj68：异步操作系统中的进程、线程和协程调度

在RISC-V平台上利用Rust语言的异步特征，在操作系统内核中设计和实现统一的进程、线程和协程调度器，以提高操作系统整体性能。

## 项目描述

项目名称：通用任务调度模块

编写不与特定操作系统绑定、适用于多种基于Rust语言和RISC-V指令集的操作系统的任务调度模块。它可以直接作为此类系统的组件，从而方便此类系统的开发。该任务调度模块能统一进行进程、线程与协程的调度，统一各类任务的管理和切换方式。

本项目的独特之处有两点。其一是支持多种操作系统（条件仅为使用Rust语言和RISC-V指令集）。其二是实现进程、线程、协程的统一调度，其中线程可以调用同步接口，而协程可以调用同步或异步两种接口，使协程更加灵活。

该任务调度系统支持的其它功能为：多核调度、抢占、中断处理、任务间通信，等等。

## 目前已完成的功能

- 向操作系统提供描述任务的接口和使用调度器的接口
- 队列管理功能（就绪队列、阻塞队列）
- 任务运行功能
- 提供任务调度算法的接口，支持多种任务调度算法
- 支持多核
- 支持线程、协程的统一调度
- trap处理程序的注册
- trap到来时，调用注册的程序进行处理
- 对时钟中断的支持，以及基于时钟中断实现的任务抢占

## 项目仓库结构

### doc目录

存放设计和开发过程中产生的各种文档。

### code目录

存储项目的代码。

项目的核心为`task_management`模块、`task_queues`模块和`trap_handler`模块。

`task_queues`模块实现了任务的队列管理功能。其中实现了调度器（及就绪队列）、阻塞队列、当前任务等存放任务的数据结构。该模块用于为`task_management`提供队列管理的支持，但不与`task_management`绑定，可以独立使用。

`task_management`模块实现了任务的数据结构和切换机制，并为外界提供了创建任务、让出、阻塞等任务管理API。。同时，还实现了代表处理器的数据结构、代表栈的数据结构等，从而支持任务的调度和运行。

`trap_handler`模块实现了对中断和异常处理的支持。该模块首先提供了trap处理入口，使得程序出现trap时，可以进入该模块进行处理。之后，它提供了注册trap处理函数的接口，既可以根据`scause`寄存器的取值注册对应的中断/异常处理函数，又可以根据外部中断号或者系统调用号注册对应的外部中断/系统调用处理函数。此外，该模块实现了时钟中断的启用和处理，并基于此实现了抢占调度。

`kernel_guard`和`scheduler`模块为引用已有的模块并加以修改。而`dependencies`中的模块是被我们的项目依赖，并依赖我们修改后的模块的那些模块。因此修改了它们的依赖路径，并未进行其它修改。

### Starry目录

该目录是将本项目部署在Starry系统上运行和演示的代码。

### minimal_runtime目录

该目录是一个尽量精简的运行时环境，为任务调度模块的运行提供最小支持，同时也证明该模块不依赖于具体操作系统。

该运行时环境基于`rCore-Tutorial ch1`章节的裸机程序，并为其增加了多核、阅读dtb、动态内存分配的功能，其中动态内存分配功能使用了`axalloc`库。通过该运行时的搭建，可知本项目的任务模块运行只需要满足如下条件：

- 基本的启动流程，能将硬件（或模拟器）正常启动，最后进入main函数并支持main函数的正常运行（例如，分配栈、零初始化.bss段，等等）。
- 动态内存分配功能，通过为`alloc`库实现`global_allocator`提供。
- rust程序必需的语义项，例如`panic_handler`。
- 项目本身运行不需要输出功能，但为了观察现象，需要提供输出功能。
- 如果需要运行多核，则需要提供在每个cpu核心启动完成后执行函数的接口。
- 如果需要支持时钟中断或抢占，则需要提供硬件的时基频率。

目前，由于提供多核支持的`percpu`库的自定义程序段会导致`minimal_runtime`编译时出现链接器错误，因此该运行时中的任务和中断模块暂时只支持单核。其它功能，如trap处理和抢占，均可以正常运行。

## 运行和演示

### 介绍

本项目可以部署在Starry系统或minimal_runtime上进行演示，使用它们提供内存分配功能与输出功能。

演示中，使用了Starry系统的unikernel模式。在该模式下，用户程序和系统内核均运行在内核态，没有地址空间的隔离。我们将项目放在用户程序中运行，并修改了Starry系统的启动代码，使得用户程序可以使用每个CPU核心。

Starry的模块化特性，使得可以对它进行配置，自由地开启和关闭一些功能。在测试程序目录`Starry/apps/scheduler_test`的`Cargo.toml`中，对`axstd`的依赖没有启用`multitask`和`irq`功能，说明测试过程没有使用Starry本身的多任务和中断处理功能，而是由本项目提供多任务、中断处理的支持。

在我们编写了数个测试程序：

- 在`test_block_wake_yield`函数中，主线程会创建多个线程和协程，每个被创建的线程和协程都会进行让出、阻塞、唤醒等操作。其中协程会调用同步和异步两种接口。观察它们同时执行时的行为，从而验证任务调度器的正确性。
- 在`test_trap`函数中，程序会注册一个trap处理函数，再相继触发一个已注册和一个未注册的trap。模块成功捕获了trap并进行处理，验证trap处理功能的正确性。
- 在`test_preempt`函数中，程序会测试创建的优先级更高的任务是否能抢占不会主动让出的主任务，从而成功输出信息。

### 运行方法

首先，确保项目的所有子模块（submodule）均被下载到本地。

之后，在项目根目录下，执行下列操作：

```Bash
# 在Starry中运行
cd Starry
./build_img.sh -a riscv64
make A=apps/scheduler_test LOG=warn ARCH=riscv64 SMP=4 run

#在minimal_runtime中运行
cd minimal_runtime
LOG=WARN make run
```

更改`Starry/apps/scheduler_test/src/main.rs`或者`minimal_runtime/src/app.rs`中，`start_main_processor`函数的参数为之前提到的几个测试程序名，可以启动不同的测试程序。

### 演示现象

![](doc/assets/屏幕截图%202024-07-31%20173942.png)

执行结果如图所示。

从图中可以发现，线程和协程可以在不同的CPU核心上运行，且在让出和阻塞时，在同一核心上交错执行。

让出操作不会改变任务所在的CPU核心，而阻塞-唤醒操作可以。实际上，唤醒操作有唤醒到当前核心和唤醒到全局调度器两种版本，而让出操作目前仅支持放回当前CPU核心，之后也会增加放到全局调度器的版本。

[演示视频](doc/演示视频.mp4)

## 引用的其它作品

### [Starry操作系统](https://github.com/Starry-OS/Starry)

Starry系统基于[ArceOS系统](https://github.com/arceos-org/arceos)，是一个基于Rust语言的模块化操作系统，它将系统功能分割为许多模块，可以根据需要启用不同的模块组合，以为系统提供不同功能。

本项目参考了Starry中任务调度模块中，对任务状态的设计。也引用了一部分相对独立的模块，以实现本项目的非核心功能，例如提供关中断临界区的`kernel_guard`，以及提供调度算法的统一接口的`scheduler`（虽然`scheduler`模块里已有一些调度算法的实现，但本项目采用的优先级调度算法是自己实现的，只是使用了`scheduler`中的接口）。

### 赵方亮的工作

赵方亮学长当前的研究工作也是结合异步的任务调度机制。他的工作之一是[AsyncStarry系统](https://github.com/zflcs/AsyncStarry/tree/dev)。在该系统中，赵方亮修改了Starry系统，设计了一个统一了线程和协程的上下文存储机制和切换机制，并为Starry系统添加了协程支持。本项目使用了该机制。但他的实现与Starry系统绑定，而本项目实现的切换机制可以应用于不同的系统中。

同时，赵方亮的工作基于他开发的自定义硬件`MOIC`，而本项目的实现不需要特殊的硬件。